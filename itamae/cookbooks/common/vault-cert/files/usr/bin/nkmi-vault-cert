#!/usr/bin/env ruby
require 'json'
require 'openssl'
require 'fileutils'

config = JSON.parse(File.read('/etc/nkmi-vault-cert.json'), symbolize_names: true)

ENV['VAULT_ADDR'] ||= config[:vault_addr]
unless ENV['VAULT_TOKEN']
  ENV['VAULT_TOKEN'] = File.read(config.fetch(:token_file)).chomp
end

units_to_reload = []
units_to_restart = []

config.fetch(:certs).each do |k, cert|
  if File.exist?(cert[:cert_file])
    threshold = (cert.fetch(:threshold_days, 7) * 86400)
    not_after = OpenSSL::X509::Certificate.new(File.read(cert[:cert_file])).not_after
    remain = not_after - Time.now
    if remain > threshold
      puts "=> #{k}: not_after=#{not_after} (skip)"
      next
    end
  end
  puts "=> #{k}: issuing"

  args = ["#{cert.fetch(:pki)}/issue/#{cert.fetch(:role)}"]
  args << "ttl=#{cert.fetch(:ttl)}" if cert[:ttl]
  args << "common_name=#{cert.fetch(:cn)}"
  args << "alt_names=#{cert.fetch(:sans).join(?,)}" if cert[:sans]
  if cert[:ip]
    ip = IO.popen(%w(ip -o r get 8.8.8.8), 'r', &:read).chomp.match(/src (.+?)(?: |$)/)[1]
    args << "ip_sans=#{ip}"
  end

  puts " * #{args.join(' ')}"

  result = IO.popen(['vault', 'write', '-format=json', *args], 'r', &:read)
  exitstatus = $?
  unless exitstatus.success?
    raise "vault-cert #{k} failed"
  end

  json = JSON.parse(result, symbolize_names: true)
  data = json.fetch(:data)

  key_file = cert.fetch(:key_file)
  File.open("#{key_file}.new", 'w', cert.fetch(:mode, '0600').to_i(8)) do |io|
    FileUtils.chown(cert.fetch(:owner, 'root'), cert.fetch(:group, 'root'), "#{key_file}.new")
    io.puts data.fetch(:private_key)
  end
  File.rename("#{key_file}.new", key_file)

  {
    cert.fetch(:ca_file) => [data.fetch(:ca_chain, data.fetch(:issuing_ca))].flatten.join(?\n),
    cert.fetch(:cert_file) => data.fetch(:certificate),
    cert.fetch(:fullchain_file) => [data.fetch(:certificate), data.fetch(:ca_chain, data.fetch(:issuing_ca))].flatten.join(?\n),
  }.each do |path, content|
    File.open("#{path}.new", 'w', 0644) do |io|
      FileUtils.chown(cert.fetch(:owner, 'root'), cert.fetch(:group, 'root'), "#{path}.new")
      io.puts content
    end
    File.rename("#{path}.new", path)
  end

  puts " * #{k}: serial=#{data.fetch(:serial_number)}"

  units_to_reload.push(*cert.fetch(:units_to_reload, []))
  units_to_restart.push(*cert.fetch(:units_to_restart, []))
end

puts "=> Notifying updates"
units_to_reload.each do |unit|
  puts " * systemctl reload #{unit}"
  system("systemctl", "reload", unit)
end
units_to_restart.each do |unit|
  puts " * systemctl restart #{unit}"
  system("systemctl", "restart", unit)
end

